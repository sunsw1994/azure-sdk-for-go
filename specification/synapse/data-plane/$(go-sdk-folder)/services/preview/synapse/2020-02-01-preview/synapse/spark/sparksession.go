package synapse

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
)

// SparkSessionClient is the client for the SparkSession methods of the Synapse service.
type SparkSessionClient struct {
    BaseClient
}
// NewSparkSessionClient creates an instance of the SparkSessionClient client.
func NewSparkSessionClient(endpoint string, sparkPoolName string) SparkSessionClient {
    return SparkSessionClient{ New(endpoint, sparkPoolName)}
}

// CancelSparkSession cancels a running spark session.
    // Parameters:
        // sessionID - identifier for the session.
func (client SparkSessionClient) CancelSparkSession(ctx context.Context, sessionID int32) (result autorest.Response, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.CancelSparkSession")
        defer func() {
            sc := -1
        if result.Response != nil {
        sc = result.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.CancelSparkSessionPreparer(ctx, sessionID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CancelSparkSession", nil , "Failure preparing request")
    return
    }

        resp, err := client.CancelSparkSessionSender(req)
        if err != nil {
        result.Response = resp
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CancelSparkSession", resp, "Failure sending request")
        return
        }

        result, err = client.CancelSparkSessionResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CancelSparkSession", resp, "Failure responding to request")
        }

    return
}

    // CancelSparkSessionPreparer prepares the CancelSparkSession request.
    func (client SparkSessionClient) CancelSparkSessionPreparer(ctx context.Context, sessionID int32) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        pathParameters := map[string]interface{} {
        "sessionId": autorest.Encode("path",sessionID),
        }

    preparer := autorest.CreatePreparer(
autorest.AsDelete(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPathParameters("/sessions/{sessionId}",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CancelSparkSessionSender sends the CancelSparkSession request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) CancelSparkSessionSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // CancelSparkSessionResponder handles the response to the CancelSparkSession request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) CancelSparkSessionResponder(resp *http.Response) (result autorest.Response, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByClosing())
            result.Response = resp
            return
    }

// CancelSparkStatement kill a statement within a session.
    // Parameters:
        // sessionID - identifier for the session.
        // statementID - identifier for the statement.
func (client SparkSessionClient) CancelSparkStatement(ctx context.Context, sessionID int32, statementID int32) (result SparkStatementCancellationResult, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.CancelSparkStatement")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.CancelSparkStatementPreparer(ctx, sessionID, statementID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CancelSparkStatement", nil , "Failure preparing request")
    return
    }

        resp, err := client.CancelSparkStatementSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CancelSparkStatement", resp, "Failure sending request")
        return
        }

        result, err = client.CancelSparkStatementResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CancelSparkStatement", resp, "Failure responding to request")
        }

    return
}

    // CancelSparkStatementPreparer prepares the CancelSparkStatement request.
    func (client SparkSessionClient) CancelSparkStatementPreparer(ctx context.Context, sessionID int32, statementID int32) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        pathParameters := map[string]interface{} {
        "sessionId": autorest.Encode("path",sessionID),
        "statementId": autorest.Encode("path",statementID),
        }

    preparer := autorest.CreatePreparer(
autorest.AsPost(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPathParameters("/sessions/{sessionId}/statements/{statementId}/cancel",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CancelSparkStatementSender sends the CancelSparkStatement request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) CancelSparkStatementSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // CancelSparkStatementResponder handles the response to the CancelSparkStatement request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) CancelSparkStatementResponder(resp *http.Response) (result SparkStatementCancellationResult, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// CreateSparkSession create new spark session.
    // Parameters:
        // sparkSessionOptions - livy compatible batch job request payload.
        // detailed - optional query param specifying whether detailed response is returned beyond plain livy.
func (client SparkSessionClient) CreateSparkSession(ctx context.Context, sparkSessionOptions SparkSessionOptions, detailed *bool) (result SparkSession, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.CreateSparkSession")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        if err := validation.Validate([]validation.Validation{
        { TargetValue: sparkSessionOptions,
         Constraints: []validation.Constraint{	{Target: "sparkSessionOptions.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
        return result, validation.NewError("synapse.SparkSessionClient", "CreateSparkSession", err.Error())
        }

        req, err := client.CreateSparkSessionPreparer(ctx, sparkSessionOptions, detailed)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CreateSparkSession", nil , "Failure preparing request")
    return
    }

        resp, err := client.CreateSparkSessionSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CreateSparkSession", resp, "Failure sending request")
        return
        }

        result, err = client.CreateSparkSessionResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CreateSparkSession", resp, "Failure responding to request")
        }

    return
}

    // CreateSparkSessionPreparer prepares the CreateSparkSession request.
    func (client SparkSessionClient) CreateSparkSessionPreparer(ctx context.Context, sparkSessionOptions SparkSessionOptions, detailed *bool) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        queryParameters := map[string]interface{} {
    }
        if detailed != nil {
        queryParameters["detailed"] = autorest.Encode("query",*detailed)
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPath("/sessions"),
autorest.WithJSON(sparkSessionOptions),
autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateSparkSessionSender sends the CreateSparkSession request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) CreateSparkSessionSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // CreateSparkSessionResponder handles the response to the CreateSparkSession request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) CreateSparkSessionResponder(resp *http.Response) (result SparkSession, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// CreateSparkStatement create statement within a spark session.
    // Parameters:
        // sessionID - identifier for the session.
        // sparkStatementOptions - livy compatible batch job request payload.
func (client SparkSessionClient) CreateSparkStatement(ctx context.Context, sessionID int32, sparkStatementOptions SparkStatementOptions) (result SparkStatement, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.CreateSparkStatement")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.CreateSparkStatementPreparer(ctx, sessionID, sparkStatementOptions)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CreateSparkStatement", nil , "Failure preparing request")
    return
    }

        resp, err := client.CreateSparkStatementSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CreateSparkStatement", resp, "Failure sending request")
        return
        }

        result, err = client.CreateSparkStatementResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "CreateSparkStatement", resp, "Failure responding to request")
        }

    return
}

    // CreateSparkStatementPreparer prepares the CreateSparkStatement request.
    func (client SparkSessionClient) CreateSparkStatementPreparer(ctx context.Context, sessionID int32, sparkStatementOptions SparkStatementOptions) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        pathParameters := map[string]interface{} {
        "sessionId": autorest.Encode("path",sessionID),
        }

    preparer := autorest.CreatePreparer(
autorest.AsContentType("application/json; charset=utf-8"),
autorest.AsPost(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPathParameters("/sessions/{sessionId}/statements",pathParameters),
autorest.WithJSON(sparkStatementOptions))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateSparkStatementSender sends the CreateSparkStatement request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) CreateSparkStatementSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // CreateSparkStatementResponder handles the response to the CreateSparkStatement request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) CreateSparkStatementResponder(resp *http.Response) (result SparkStatement, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSparkSession gets a single spark session.
    // Parameters:
        // sessionID - identifier for the session.
        // detailed - optional query param specifying whether detailed response is returned beyond plain livy.
func (client SparkSessionClient) GetSparkSession(ctx context.Context, sessionID int32, detailed *bool) (result SparkSession, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.GetSparkSession")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetSparkSessionPreparer(ctx, sessionID, detailed)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkSession", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSparkSessionSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkSession", resp, "Failure sending request")
        return
        }

        result, err = client.GetSparkSessionResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkSession", resp, "Failure responding to request")
        }

    return
}

    // GetSparkSessionPreparer prepares the GetSparkSession request.
    func (client SparkSessionClient) GetSparkSessionPreparer(ctx context.Context, sessionID int32, detailed *bool) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        pathParameters := map[string]interface{} {
        "sessionId": autorest.Encode("path",sessionID),
        }

        queryParameters := map[string]interface{} {
    }
        if detailed != nil {
        queryParameters["detailed"] = autorest.Encode("query",*detailed)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPathParameters("/sessions/{sessionId}",pathParameters),
autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSparkSessionSender sends the GetSparkSession request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) GetSparkSessionSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // GetSparkSessionResponder handles the response to the GetSparkSession request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) GetSparkSessionResponder(resp *http.Response) (result SparkSession, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSparkSessions list all spark sessions which are running under a particular spark pool.
    // Parameters:
        // from - optional param specifying which index the list should begin from.
        // size - optional param specifying the size of the returned list.
        // By default it is 20 and that is the maximum.
        // detailed - optional query param specifying whether detailed response is returned beyond plain livy.
func (client SparkSessionClient) GetSparkSessions(ctx context.Context, from *int32, size *int32, detailed *bool) (result SparkSessionCollection, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.GetSparkSessions")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetSparkSessionsPreparer(ctx, from, size, detailed)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkSessions", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSparkSessionsSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkSessions", resp, "Failure sending request")
        return
        }

        result, err = client.GetSparkSessionsResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkSessions", resp, "Failure responding to request")
        }

    return
}

    // GetSparkSessionsPreparer prepares the GetSparkSessions request.
    func (client SparkSessionClient) GetSparkSessionsPreparer(ctx context.Context, from *int32, size *int32, detailed *bool) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        queryParameters := map[string]interface{} {
    }
        if from != nil {
        queryParameters["from"] = autorest.Encode("query",*from)
        }
        if size != nil {
        queryParameters["size"] = autorest.Encode("query",*size)
        }
        if detailed != nil {
        queryParameters["detailed"] = autorest.Encode("query",*detailed)
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPath("/sessions"),
autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSparkSessionsSender sends the GetSparkSessions request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) GetSparkSessionsSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // GetSparkSessionsResponder handles the response to the GetSparkSessions request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) GetSparkSessionsResponder(resp *http.Response) (result SparkSessionCollection, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSparkStatement gets a single statement within a spark session.
    // Parameters:
        // sessionID - identifier for the session.
        // statementID - identifier for the statement.
func (client SparkSessionClient) GetSparkStatement(ctx context.Context, sessionID int32, statementID int32) (result SparkStatement, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.GetSparkStatement")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetSparkStatementPreparer(ctx, sessionID, statementID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkStatement", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSparkStatementSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkStatement", resp, "Failure sending request")
        return
        }

        result, err = client.GetSparkStatementResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkStatement", resp, "Failure responding to request")
        }

    return
}

    // GetSparkStatementPreparer prepares the GetSparkStatement request.
    func (client SparkSessionClient) GetSparkStatementPreparer(ctx context.Context, sessionID int32, statementID int32) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        pathParameters := map[string]interface{} {
        "sessionId": autorest.Encode("path",sessionID),
        "statementId": autorest.Encode("path",statementID),
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPathParameters("/sessions/{sessionId}/statements/{statementId}",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSparkStatementSender sends the GetSparkStatement request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) GetSparkStatementSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // GetSparkStatementResponder handles the response to the GetSparkStatement request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) GetSparkStatementResponder(resp *http.Response) (result SparkStatement, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// GetSparkStatements gets a list of statements within a spark session.
    // Parameters:
        // sessionID - identifier for the session.
func (client SparkSessionClient) GetSparkStatements(ctx context.Context, sessionID int32) (result SparkStatementCollection, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.GetSparkStatements")
        defer func() {
            sc := -1
        if result.Response.Response != nil {
        sc = result.Response.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.GetSparkStatementsPreparer(ctx, sessionID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkStatements", nil , "Failure preparing request")
    return
    }

        resp, err := client.GetSparkStatementsSender(req)
        if err != nil {
        result.Response = autorest.Response{Response: resp}
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkStatements", resp, "Failure sending request")
        return
        }

        result, err = client.GetSparkStatementsResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "GetSparkStatements", resp, "Failure responding to request")
        }

    return
}

    // GetSparkStatementsPreparer prepares the GetSparkStatements request.
    func (client SparkSessionClient) GetSparkStatementsPreparer(ctx context.Context, sessionID int32) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        pathParameters := map[string]interface{} {
        "sessionId": autorest.Encode("path",sessionID),
        }

    preparer := autorest.CreatePreparer(
autorest.AsGet(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPathParameters("/sessions/{sessionId}/statements",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetSparkStatementsSender sends the GetSparkStatements request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) GetSparkStatementsSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // GetSparkStatementsResponder handles the response to the GetSparkStatements request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) GetSparkStatementsResponder(resp *http.Response) (result SparkStatementCollection, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
            result.Response = autorest.Response{Response: resp}
            return
    }

// ResetSparkSessionTimeout sends a keep alive call to the current session to reset the session timeout.
    // Parameters:
        // sessionID - identifier for the session.
func (client SparkSessionClient) ResetSparkSessionTimeout(ctx context.Context, sessionID int32) (result autorest.Response, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/SparkSessionClient.ResetSparkSessionTimeout")
        defer func() {
            sc := -1
        if result.Response != nil {
        sc = result.Response.StatusCode
        }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
    req, err := client.ResetSparkSessionTimeoutPreparer(ctx, sessionID)
    if err != nil {
    err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "ResetSparkSessionTimeout", nil , "Failure preparing request")
    return
    }

        resp, err := client.ResetSparkSessionTimeoutSender(req)
        if err != nil {
        result.Response = resp
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "ResetSparkSessionTimeout", resp, "Failure sending request")
        return
        }

        result, err = client.ResetSparkSessionTimeoutResponder(resp)
        if err != nil {
        err = autorest.NewErrorWithError(err, "synapse.SparkSessionClient", "ResetSparkSessionTimeout", resp, "Failure responding to request")
        }

    return
}

    // ResetSparkSessionTimeoutPreparer prepares the ResetSparkSessionTimeout request.
    func (client SparkSessionClient) ResetSparkSessionTimeoutPreparer(ctx context.Context, sessionID int32) (*http.Request, error) {
        urlParameters := map[string]interface{} {
        "endpoint": client.Endpoint,
        "livyApiVersion": client.LivyAPIVersion,
        "sparkPoolName": client.SparkPoolName,
        }

        pathParameters := map[string]interface{} {
        "sessionId": autorest.Encode("path",sessionID),
        }

    preparer := autorest.CreatePreparer(
autorest.AsPut(),
autorest.WithCustomBaseURL("{endpoint}/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}", urlParameters),
autorest.WithPathParameters("/sessions/{sessionId}/reset-timeout",pathParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ResetSparkSessionTimeoutSender sends the ResetSparkSessionTimeout request. The method will close the
    // http.Response Body if it receives an error.
    func (client SparkSessionClient) ResetSparkSessionTimeoutSender(req *http.Request) (*http.Response, error) {
            return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

    // ResetSparkSessionTimeoutResponder handles the response to the ResetSparkSessionTimeout request. The method always
    // closes the http.Response Body.
    func (client SparkSessionClient) ResetSparkSessionTimeoutResponder(resp *http.Response) (result autorest.Response, err error) {
            err = autorest.Respond(
            resp,
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByClosing())
            result.Response = resp
            return
    }

